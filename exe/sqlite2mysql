#!/usr/bin/env ruby

require 'sqlite2mysql'

Sqlite2Mysql.run(ARGV)

# require 'mysql2'
# require 'sqlite3'

# puts 'Usage: sqlite2mysql sqlite_file.db [mysql_db_name]' if ARGV.size < 1

# DATABASE = ARGV.first
# SQL_DB_NAME = ARGV[1] || DATABASE.gsub(/[^0-9a-z]/i, '')

# puts 'Collecting Sqlit3 Info' # ===============================================

# db = SQLite3::Database.new DATABASE

# schema = {}

# tables = db.execute 'SELECT name FROM sqlite_master WHERE type="table"'

# tables.flatten.each do |t|
#   columns = db.execute("pragma table_info(#{t})")

#   formatted_columns = []
#   columns.each do |col|
#     formatted_columns << { name:    col[1],
#                            type:    col[2],
#                            notnull: col[3],
#                            default: col[4] }
#   end

#   schema[t] = formatted_columns
# end

# puts "Creating MySQL DB: #{SQL_DB_NAME}" # ====================================

# RESERVED_WORDS = %w(key int)

# def create_table_query(table, columns)
#   query = "CREATE TABLE #{table} ("
#   cols = []
#   columns.each do |col|
#     col[:name] += '_1' if RESERVED_WORDS.include?(col[:name])
#     if col[:type] == ''
#       col[:type] = 'varchar(255)'
#     elsif col[:type].start_with?('float')
#       col[:type] = 'float'
#     end
#     cols << "#{col[:name]} #{col[:type]} #{'NOT NULL' if col[:notnull]}"
#   end
#   query + "#{cols.join(', ')})"
# end

# client = Mysql2::Client.new(host: 'localhost', username: 'root')

# client.query("DROP DATABASE IF EXISTS #{SQL_DB_NAME}")
# client.query("CREATE DATABASE #{SQL_DB_NAME}")
# client.query("USE #{SQL_DB_NAME}")

# schema.keys.each do |table|
#   puts "Creating table: #{table}"
#   client.query(create_table_query(table, schema[table]))
# end

# print 'Grab a â˜•' # ============================================================

# schema.keys.each do |table|
#   puts "\nInserting data: #{table}"
#   data = db.execute("select * from #{table}")
#   data.each_slice(1000) do |slice|
#     slice.each do |row|
#       cleaned_row = row.map do |val|
#         val.is_a?(String) ? client.escape(val) : val
#       end
#       client.query("INSERT INTO #{table} VALUES (\"#{cleaned_row.join('", "')}\")")
#     end
#     print '.'
#   end
# end
# puts ''
